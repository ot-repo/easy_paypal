// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'approval_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

PPApprovalData _$PPApprovalDataFromJson(Map<String, dynamic> json) {
  return _PPApprovalData.fromJson(json);
}

/// @nodoc
mixin _$PPApprovalData {
  String? get payerId => throw _privateConstructorUsedError;
  String? get orderId => throw _privateConstructorUsedError;
  String? get paymentId => throw _privateConstructorUsedError;
  PPBuyer? get payer => throw _privateConstructorUsedError;
  PPCart? get cart => throw _privateConstructorUsedError;
  PPVaultData? get vaultData => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PPApprovalDataCopyWith<PPApprovalData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PPApprovalDataCopyWith<$Res> {
  factory $PPApprovalDataCopyWith(
          PPApprovalData value, $Res Function(PPApprovalData) then) =
      _$PPApprovalDataCopyWithImpl<$Res, PPApprovalData>;
  @useResult
  $Res call(
      {String? payerId,
      String? orderId,
      String? paymentId,
      PPBuyer? payer,
      PPCart? cart,
      PPVaultData? vaultData});

  $PPBuyerCopyWith<$Res>? get payer;
  $PPCartCopyWith<$Res>? get cart;
  $PPVaultDataCopyWith<$Res>? get vaultData;
}

/// @nodoc
class _$PPApprovalDataCopyWithImpl<$Res, $Val extends PPApprovalData>
    implements $PPApprovalDataCopyWith<$Res> {
  _$PPApprovalDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? payerId = freezed,
    Object? orderId = freezed,
    Object? paymentId = freezed,
    Object? payer = freezed,
    Object? cart = freezed,
    Object? vaultData = freezed,
  }) {
    return _then(_value.copyWith(
      payerId: freezed == payerId
          ? _value.payerId
          : payerId // ignore: cast_nullable_to_non_nullable
              as String?,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentId: freezed == paymentId
          ? _value.paymentId
          : paymentId // ignore: cast_nullable_to_non_nullable
              as String?,
      payer: freezed == payer
          ? _value.payer
          : payer // ignore: cast_nullable_to_non_nullable
              as PPBuyer?,
      cart: freezed == cart
          ? _value.cart
          : cart // ignore: cast_nullable_to_non_nullable
              as PPCart?,
      vaultData: freezed == vaultData
          ? _value.vaultData
          : vaultData // ignore: cast_nullable_to_non_nullable
              as PPVaultData?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PPBuyerCopyWith<$Res>? get payer {
    if (_value.payer == null) {
      return null;
    }

    return $PPBuyerCopyWith<$Res>(_value.payer!, (value) {
      return _then(_value.copyWith(payer: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PPCartCopyWith<$Res>? get cart {
    if (_value.cart == null) {
      return null;
    }

    return $PPCartCopyWith<$Res>(_value.cart!, (value) {
      return _then(_value.copyWith(cart: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PPVaultDataCopyWith<$Res>? get vaultData {
    if (_value.vaultData == null) {
      return null;
    }

    return $PPVaultDataCopyWith<$Res>(_value.vaultData!, (value) {
      return _then(_value.copyWith(vaultData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PPApprovalDataCopyWith<$Res>
    implements $PPApprovalDataCopyWith<$Res> {
  factory _$$_PPApprovalDataCopyWith(
          _$_PPApprovalData value, $Res Function(_$_PPApprovalData) then) =
      __$$_PPApprovalDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? payerId,
      String? orderId,
      String? paymentId,
      PPBuyer? payer,
      PPCart? cart,
      PPVaultData? vaultData});

  @override
  $PPBuyerCopyWith<$Res>? get payer;
  @override
  $PPCartCopyWith<$Res>? get cart;
  @override
  $PPVaultDataCopyWith<$Res>? get vaultData;
}

/// @nodoc
class __$$_PPApprovalDataCopyWithImpl<$Res>
    extends _$PPApprovalDataCopyWithImpl<$Res, _$_PPApprovalData>
    implements _$$_PPApprovalDataCopyWith<$Res> {
  __$$_PPApprovalDataCopyWithImpl(
      _$_PPApprovalData _value, $Res Function(_$_PPApprovalData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? payerId = freezed,
    Object? orderId = freezed,
    Object? paymentId = freezed,
    Object? payer = freezed,
    Object? cart = freezed,
    Object? vaultData = freezed,
  }) {
    return _then(_$_PPApprovalData(
      payerId: freezed == payerId
          ? _value.payerId
          : payerId // ignore: cast_nullable_to_non_nullable
              as String?,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentId: freezed == paymentId
          ? _value.paymentId
          : paymentId // ignore: cast_nullable_to_non_nullable
              as String?,
      payer: freezed == payer
          ? _value.payer
          : payer // ignore: cast_nullable_to_non_nullable
              as PPBuyer?,
      cart: freezed == cart
          ? _value.cart
          : cart // ignore: cast_nullable_to_non_nullable
              as PPCart?,
      vaultData: freezed == vaultData
          ? _value.vaultData
          : vaultData // ignore: cast_nullable_to_non_nullable
              as PPVaultData?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PPApprovalData
    with DiagnosticableTreeMixin
    implements _PPApprovalData {
  const _$_PPApprovalData(
      {this.payerId,
      this.orderId,
      this.paymentId,
      this.payer,
      this.cart,
      this.vaultData});

  factory _$_PPApprovalData.fromJson(Map<String, dynamic> json) =>
      _$$_PPApprovalDataFromJson(json);

  @override
  final String? payerId;
  @override
  final String? orderId;
  @override
  final String? paymentId;
  @override
  final PPBuyer? payer;
  @override
  final PPCart? cart;
  @override
  final PPVaultData? vaultData;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PPApprovalData(payerId: $payerId, orderId: $orderId, paymentId: $paymentId, payer: $payer, cart: $cart, vaultData: $vaultData)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PPApprovalData'))
      ..add(DiagnosticsProperty('payerId', payerId))
      ..add(DiagnosticsProperty('orderId', orderId))
      ..add(DiagnosticsProperty('paymentId', paymentId))
      ..add(DiagnosticsProperty('payer', payer))
      ..add(DiagnosticsProperty('cart', cart))
      ..add(DiagnosticsProperty('vaultData', vaultData));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PPApprovalData &&
            (identical(other.payerId, payerId) || other.payerId == payerId) &&
            (identical(other.orderId, orderId) || other.orderId == orderId) &&
            (identical(other.paymentId, paymentId) ||
                other.paymentId == paymentId) &&
            (identical(other.payer, payer) || other.payer == payer) &&
            (identical(other.cart, cart) || other.cart == cart) &&
            (identical(other.vaultData, vaultData) ||
                other.vaultData == vaultData));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, payerId, orderId, paymentId, payer, cart, vaultData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PPApprovalDataCopyWith<_$_PPApprovalData> get copyWith =>
      __$$_PPApprovalDataCopyWithImpl<_$_PPApprovalData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PPApprovalDataToJson(
      this,
    );
  }
}

abstract class _PPApprovalData implements PPApprovalData {
  const factory _PPApprovalData(
      {final String? payerId,
      final String? orderId,
      final String? paymentId,
      final PPBuyer? payer,
      final PPCart? cart,
      final PPVaultData? vaultData}) = _$_PPApprovalData;

  factory _PPApprovalData.fromJson(Map<String, dynamic> json) =
      _$_PPApprovalData.fromJson;

  @override
  String? get payerId;
  @override
  String? get orderId;
  @override
  String? get paymentId;
  @override
  PPBuyer? get payer;
  @override
  PPCart? get cart;
  @override
  PPVaultData? get vaultData;
  @override
  @JsonKey(ignore: true)
  _$$_PPApprovalDataCopyWith<_$_PPApprovalData> get copyWith =>
      throw _privateConstructorUsedError;
}
